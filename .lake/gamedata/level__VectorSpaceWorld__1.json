{"title": "Vector space intro, zero scalar multiplication",
 "template": null,
 "tactics":
 [{"new": false,
   "name": "apply",
   "locked": false,
   "hidden": false,
   "displayName": "apply",
   "disabled": false,
   "category": "",
   "altTitle": ""},
  {"new": false,
   "name": "cases'",
   "locked": false,
   "hidden": false,
   "displayName": "cases'",
   "disabled": false,
   "category": "",
   "altTitle": ""},
  {"new": false,
   "name": "constructor",
   "locked": false,
   "hidden": false,
   "displayName": "constructor",
   "disabled": false,
   "category": "",
   "altTitle": ""},
  {"new": false,
   "name": "exact",
   "locked": false,
   "hidden": false,
   "displayName": "exact",
   "disabled": false,
   "category": "",
   "altTitle": ""},
  {"new": false,
   "name": "exfalso",
   "locked": false,
   "hidden": false,
   "displayName": "exfalso",
   "disabled": false,
   "category": "",
   "altTitle": ""},
  {"new": false,
   "name": "induction'",
   "locked": false,
   "hidden": false,
   "displayName": "induction'",
   "disabled": false,
   "category": "",
   "altTitle": ""},
  {"new": false,
   "name": "intro",
   "locked": false,
   "hidden": false,
   "displayName": "intro",
   "disabled": false,
   "category": "",
   "altTitle": ""},
  {"new": false,
   "name": "intros",
   "locked": false,
   "hidden": true,
   "displayName": "intros",
   "disabled": false,
   "category": "",
   "altTitle": ""},
  {"new": false,
   "name": "linarith",
   "locked": false,
   "hidden": false,
   "displayName": "linarith",
   "disabled": true,
   "category": "",
   "altTitle": ""},
  {"new": false,
   "name": "nth_rewrite",
   "locked": false,
   "hidden": true,
   "displayName": "nth_rewrite",
   "disabled": false,
   "category": "",
   "altTitle": ""},
  {"new": false,
   "name": "obtain",
   "locked": true,
   "hidden": false,
   "displayName": "obtain",
   "disabled": false,
   "category": "",
   "altTitle": ""},
  {"new": false,
   "name": "repeat",
   "locked": false,
   "hidden": true,
   "displayName": "repeat",
   "disabled": false,
   "category": "",
   "altTitle": ""},
  {"new": false,
   "name": "rfl",
   "locked": false,
   "hidden": false,
   "displayName": "rfl",
   "disabled": false,
   "category": "",
   "altTitle": ""},
  {"new": false,
   "name": "rw",
   "locked": false,
   "hidden": false,
   "displayName": "rw",
   "disabled": false,
   "category": "",
   "altTitle": ""},
  {"new": false,
   "name": "simp",
   "locked": false,
   "hidden": false,
   "displayName": "simp",
   "disabled": true,
   "category": "",
   "altTitle": ""},
  {"new": true,
   "name": "symm",
   "locked": false,
   "hidden": false,
   "displayName": "symm",
   "disabled": false,
   "category": "",
   "altTitle": ""},
  {"new": false,
   "name": "unfold",
   "locked": false,
   "hidden": false,
   "displayName": "unfold",
   "disabled": false,
   "category": "",
   "altTitle": ""},
  {"new": false,
   "name": "use",
   "locked": false,
   "hidden": false,
   "displayName": "use",
   "disabled": false,
   "category": "",
   "altTitle": ""}],
 "statementName": "LinearAlgebraGame.zero_smul_v",
 "module": "Game.Levels.VectorSpaceWorld.Level01",
 "lemmas":
 [{"new": false,
   "name": "LinearAlgebraGame.neg_one_smul_v",
   "locked": true,
   "hidden": false,
   "displayName": "neg_one_smul_v",
   "disabled": false,
   "category": "Vector Spaces",
   "altTitle":
   " {K V} (fk : Field K) (acg : AddCommGroup V) (vs : LinearAlgebraGame.VectorSpace K V) (v : V) : -1 • v = -v"},
  {"new": false,
   "name": "LinearAlgebraGame.smul_zero_v",
   "locked": true,
   "hidden": false,
   "displayName": "smul_zero_v",
   "disabled": false,
   "category": "Vector Spaces",
   "altTitle":
   " {K V} (fk : Field K) (acg : AddCommGroup V) (vs : LinearAlgebraGame.VectorSpace K V) (a : K) : a • 0 = 0"},
  {"new": false,
   "name": "LinearAlgebraGame.subspace_contains_zero",
   "locked": true,
   "hidden": false,
   "displayName": "subspace_contains_zero",
   "disabled": false,
   "category": "Vector Spaces",
   "altTitle":
   " {K V} (fk : Field K) (acg : AddCommGroup V) (vs : LinearAlgebraGame.VectorSpace K V) {W}\n  (hW : LinearAlgebraGame.isSubspace W) : 0 ∈ W"},
  {"new": false,
   "name": "LinearAlgebraGame.subspace_neg",
   "locked": true,
   "hidden": false,
   "displayName": "subspace_neg",
   "disabled": false,
   "category": "Vector Spaces",
   "altTitle":
   " {K V} (fk : Field K) (acg : AddCommGroup V) (vs : LinearAlgebraGame.VectorSpace K V) {W}\n  (hW : LinearAlgebraGame.isSubspace W) (x : V) (a✝ : x ∈ W) : -x ∈ W"},
  {"new": false,
   "name": "LinearAlgebraGame.zero_smul_v",
   "locked": true,
   "hidden": false,
   "displayName": "zero_smul_v",
   "disabled": false,
   "category": "Vector Spaces",
   "altTitle":
   " {K V} (fk : Field K) (acg : AddCommGroup V) (vs : LinearAlgebraGame.VectorSpace K V) (w : V) : 0 • w = 0"},
  {"new": true,
   "name": "MulAction.mul_smul",
   "locked": false,
   "hidden": false,
   "displayName": "mul_smul",
   "disabled": false,
   "category": "Vector Spaces",
   "altTitle":
   " {α} {β} [Monoid α] [MulAction α β] (x y : α) (b : β) : (x * y) • b = x • y • b"},
  {"new": false,
   "name": "Nat.add_succ",
   "locked": false,
   "hidden": false,
   "displayName": "add_succ",
   "disabled": false,
   "category": "ℕ",
   "altTitle": " (n m : ℕ) : n + Nat.succ m = Nat.succ (n + m)"},
  {"new": false,
   "name": "add_neg_self",
   "locked": true,
   "hidden": false,
   "displayName": "add_neg_self",
   "disabled": false,
   "category": "Groups",
   "altTitle": " {G} [AddGroup G] (a : G) : a + -a = 0"},
  {"new": true,
   "name": "add_right_cancel",
   "locked": false,
   "hidden": false,
   "displayName": "add_right_cancel",
   "disabled": false,
   "category": "Groups",
   "altTitle":
   " {G} [Add G] [IsRightCancelAdd G] {a b c} (a✝ : a + b = c + b) : a = c"},
  {"new": true,
   "name": "add_smul",
   "locked": false,
   "hidden": false,
   "displayName": "add_smul",
   "disabled": false,
   "category": "Vector Spaces",
   "altTitle":
   " {R} {M} [Semiring R] [AddCommMonoid M] [Module R M] (r s : R) (x : M) : (r + s) • x = r • x + s • x"},
  {"new": true,
   "name": "add_zero",
   "locked": false,
   "hidden": false,
   "displayName": "add_zero",
   "disabled": false,
   "category": "Groups",
   "altTitle": " {M} [AddZeroClass M] (a : M) : a + 0 = a"},
  {"new": false,
   "name": "le_iff_exists_add",
   "locked": false,
   "hidden": false,
   "displayName": "le_iff_exists_add",
   "disabled": false,
   "category": "ℕ",
   "altTitle":
   " {α} [CanonicallyOrderedAddCommMonoid α] {a b} : a ≤ b ↔ ∃ c, b = a + c"},
  {"new": false,
   "name": "neg_add_self",
   "locked": true,
   "hidden": false,
   "displayName": "neg_add_self",
   "disabled": false,
   "category": "Groups",
   "altTitle": " {G} [AddGroup G] (a : G) : -a + a = 0"},
  {"new": true,
   "name": "one_smul",
   "locked": false,
   "hidden": false,
   "displayName": "one_smul",
   "disabled": false,
   "category": "Vector Spaces",
   "altTitle":
   " (M : Type u_1) {α} [Monoid M] [MulAction M α] (b : α) : 1 • b = b"},
  {"new": true,
   "name": "smul_add",
   "locked": false,
   "hidden": false,
   "displayName": "smul_add",
   "disabled": false,
   "category": "Vector Spaces",
   "altTitle":
   " {M} {A} [AddZeroClass A] [DistribSMul M A] (a : M) (b₁ b₂ : A) : a • (b₁ + b₂) = a • b₁ + a • b₂"},
  {"new": true,
   "name": "symm",
   "locked": false,
   "hidden": false,
   "displayName": "symm",
   "disabled": false,
   "category": "Lean",
   "altTitle": " {α} {r} [IsSymm α r] {a b} (a✝ : r a b) : r b a"},
  {"new": true,
   "name": "zero_add",
   "locked": false,
   "hidden": false,
   "displayName": "zero_add",
   "disabled": false,
   "category": "Groups",
   "altTitle": " {M} [AddZeroClass M] (a : M) : 0 + a = a"}],
 "lemmaTab": "Groups",
 "introduction":
 "## Vector Space Definition\n\nWe begin by defining a vector space over a field `K` with an abelian group `V`. This class includes four key axioms:\n\n```\nclass VectorSpace (K V : Type) [Field K] [AddCommGroup V] extends SMul K V where\n  smul_add : ∀ (a : K) (x y : V), a • (x + y) = a • x + a • y           -- distributivity of scalar over vector addition\n  add_smul : ∀ (a b : K) (x : V), (a + b) • x = a • x + b • x           -- distributivity of scalar addition\n  mul_smul : ∀ (a b : K) (x : V), (a * b) • x = a • (b • x)             -- compatibility of scalar multiplication\n  one_smul : ∀ (x : V), (1 : K) • x = x                                -- identity scalar acts as identity\n```\n\nThis foundational structure will be used throughout all future levels. No proof is needed here\n— just understand the axioms and how they're represented. Note that to write the `•` character, type\n\"\\smul\"\n\n## Goal for this level\n\nIn this level, you'll prove that multiplying a vector by the zero scalar (`0 : K`) results in the\nzero vector (`0 : V`). This is going to be a slightly involved proof, so it is important to get an\nunderstanding of the proof before beginning to write it.\n\nThe first step of a normal proof would be writing `0 • w` as `(0 + 0) • w`, then using distributivity\nto get it as `0 • w + 0 • w`. Lastly, cancelling out a `0 • w` on each side gets `0 = 0 • w`.\n\nHowever, this proof relies on our assumptions and constructs the goal from them. This can be done in\nLean, however, it requires using the `have` tactic, and is unnescessarily complex. In Lean, proofs are\noften done backwards, working from the goal and creating the hypotheses.\n\nDoing the proof backwards thus must first involve adding `0 • w` to both sides of the goal, undoing\ndistributivity, then cancelling out some zeros.\n\n### add_right_cancel\n\nTo use cancellation of addition, we need a new theorem, `add_right_cancel`. This theorem is a proof\nthat `a + b = c + b → a = c`. Since your goal is of the form `a = c`, `apply add_right_cancel` will\nchange the goal to `a + ?b = c + ?b`. However, you want to be able to write the value of `?b`, but\nin this case, Lean doesn't know what value you want to add. You can tell Lean what to add to the\nequation by `apply add_right_cancel (b := ????)`, replacing the question marks with whatever you\nwant to add.\n\n### zero_add\n\nWe also need to know some basic theorems about addition. For both the scalars and vectors, adding any\nvector to `0` will result in that vector. Simply `rw [zero_add]` will show this.\n\n### symm\n\nYou will also need the `symm` tactic. `symm` stands for symmetry of equality, and it can be used to\nchange goals of the form `a = b` to `b = a`. `symm at h` will also change a hypothesis `h: a = b` to\n`h: b = a`. However, neither of these uses are needed in this level. You may\nnotice that if `h: a = b` is a hypothesis, rw[h] will rewrite all `a`s to `b`s. What if you want to\nrewrite all `b`s to `a`s, you can instead do `rw[h.symm]`.\n\nAlso note that when the theorem has a `∀` symbol, as in `∀ a b : S, a + b = b + a`, you need to\nspecify what `a` and `b` you mean to use before using `.symm`. For example, you would have to write\n`rw[(h 2 3).symm]`.\n\nOne last hint is that when writing `0`, you often want to specify which zero you are talking about.\nWe know that the natural numbers, for example, has a `0`, but so do the Field K and the Abelian Group\nV, and those `0`s are different. To specify which `0` you are talking about, write `(0 : K)` or `(0 : V)`.\n\n### Note on simp and linarith\n\nIn this world, we are primarilly proving simple statements about vector spaces. This is exactly what\nthe `simp` and `linarith` tactics are meant to do. In fact, the `simp` tactic alone would be able to\nsolve the first three levels of this world. Because of this, you will not be able to use those tactics\nin this world.",
 "index": 1,
 "image": "",
 "displayName": "zero_smul_v",
 "descrText":
 "In any vector space V over K, the scalar 0 multiplied by any vector gives the zero vector.",
 "descrFormat":
 "theorem zero_smul_v (fk : Field K) (acg : AddCommGroup V) (vs : VectorSpace K V) (w : V) : (0 : K) • w = (0 : V)  := by",
 "definitions":
 [{"new": true,
   "name": "VectorSpace_w1",
   "locked": false,
   "hidden": false,
   "displayName": "Vector Space",
   "disabled": false,
   "category": "",
   "altTitle": ""},
  {"new": false,
   "name": "isSubspace",
   "locked": true,
   "hidden": false,
   "displayName": "isSubspace",
   "disabled": false,
   "category": "",
   "altTitle": ""}],
 "conclusion":
 "You have now proven your first theorem about vector spaces! One note: if you want to use\none of the theorems you prove in one level in another level, the syntax will be\n`theorem_name fk acg vs theorem_args`. This is because we take as hypotheses in each level that\nK is a Field, V is an abelian group, and K V is a vector space. To use a theorem, we need to include\nproofs of those statements."}